<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客运维记录</title>
      <link href="2020/10/01/bo-ke-yun-wei-ji-lu/"/>
      <url>2020/10/01/bo-ke-yun-wei-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>文章记录博客(基于 HEXO + NEXT )运维命令、配置与变更等，用于快速翻看。</p><h2 id="博客建设与维护"><a href="#博客建设与维护" class="headerlink" title="博客建设与维护"></a>博客建设与维护</h2><h3 id="建设"><a href="#建设" class="headerlink" title="建设"></a>建设</h3><h3 id="分类规划"><a href="#分类规划" class="headerlink" title="分类规划"></a>分类规划</h3><h3 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h3><p><code>vscode</code> 中用 <code>picgo</code> 插件<br>床图用阿里云 oss</p><h2 id="个人写作规范"><a href="#个人写作规范" class="headerlink" title="个人写作规范"></a>个人写作规范</h2><h2 id="日常运维命令"><a href="#日常运维命令" class="headerlink" title="日常运维命令"></a>日常运维命令</h2><h3 id="HEXO-维护"><a href="#HEXO-维护" class="headerlink" title="HEXO 维护"></a>HEXO 维护</h3><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo -g <span class="token comment" spellcheck="true">#安装  </span>$ <span class="token function">npm</span> update hexo -g <span class="token comment" spellcheck="true">#升级  </span>$ hexo init <span class="token comment" spellcheck="true">#初始化</span></code></pre><h3 id="删除git-commit历史"><a href="#删除git-commit历史" class="headerlink" title="删除git commit历史"></a>删除git commit历史</h3><ol><li>备份<code>.deploy_git</code>文件夹。</li><li>删除<code>.deploy_git</code>和<code>public</code>文件夹。</li><li>删除对应的远程分支。</li><li>进入<code>hexo</code>根目录。</li><li>清除、重新生成并部署至远程仓库。</li></ol><pre class=" language-bash"><code class="language-bash">$ hexo clean$ hexo g -d</code></pre><h3 id="备份-hexo-源文件"><a href="#备份-hexo-源文件" class="headerlink" title="备份 hexo 源文件"></a>备份 hexo 源文件</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>对<code>Hexo</code>源文件进行备份，以便再更换工作环境后进行重新部署。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>创建 <code>hexo</code> 分支来存放<code>Hexo</code>生成的网站源文件，用<code>master</code>分支来存放生成的静态网页。</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ol><li><code>.gitignore</code> 文件为<code>hexo</code>默认配置：</li></ol><pre><code>.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/</code></pre><ol start="2"><li>切换到 <code>Hexo</code> 根目录，依次运行以下命令</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#git初始化</span>$ <span class="token function">git</span> init<span class="token comment" spellcheck="true">#创建hexo分支，用来存放源码</span>$ <span class="token function">git</span> checkout -b hexo<span class="token comment" spellcheck="true">#git 文件添加</span>$ <span class="token function">git</span> add <span class="token keyword">.</span><span class="token comment" spellcheck="true">#git 提交</span>$ <span class="token function">git</span> commit -m <span class="token string">"init"</span><span class="token comment" spellcheck="true">#配置 github 远程仓库</span>$ <span class="token function">git</span> remote add origin git@github.com:wudision0416/wudision0416.github.io.git<span class="token comment" spellcheck="true">#配置 coding 远程仓库</span>$ <span class="token function">git</span> remote add coding git@git.dev.tencent.com:wudision0416/wudision0416.git<span class="token comment" spellcheck="true">#push 到 github 的 hexo 分支</span>$ <span class="token function">git</span> push origin hexo<span class="token comment" spellcheck="true">#push 到 coding 的 hexo 分支</span>$ <span class="token function">git</span> push coding hexo</code></pre><ol start="3"><li>在 <code>Github</code> 与 <code>coding</code> 上对应的博客仓库中设置默认分支为<code>hexo</code>。这样有助于以后恢复博客环境。<code>master</code>分支为博客静态页面分支，在之后恢复博客的时候并不需要。</li></ol><h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>输入下列命令克隆博客必须文件(<code>hexo</code>分支)：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#安装 hexo</span>$ <span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli<span class="token comment" spellcheck="true">#从 GitHub 的仓库中恢复</span>$ <span class="token function">git</span> clone git@github.com:wudision0416/wudision0416.github.io.git Blog<span class="token comment" spellcheck="true">#从 coding 的仓库中恢复</span>$ <span class="token function">git</span> clone git@git.dev.tencent.com:wudision0416/wudision0416.git Blog<span class="token comment" spellcheck="true">#进入博客根目录</span>$ <span class="token function">cd</span> ./Blog<span class="token comment" spellcheck="true">#安装 npm 包</span>$ <span class="token function">npm</span> <span class="token function">install</span>$ <span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git</code></pre><p>不需要执行<code>hexo init</code>这条指令，因为不是从零搭建起新博客。</p><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>先执行<code>hexo g -d</code>，把要发布的内容<code>push</code>到<code>github</code>或<code>coding</code>上面了，再去弄备份。</p><h3 id="创建新的文章"><a href="#创建新的文章" class="headerlink" title="创建新的文章"></a>创建新的文章</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">></span></code></pre><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <code>_config.yml</code> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-p</code>, <code>--path</code></td><td>自定义新文章的路径</td></tr><tr><td><code>-r</code>, <code>--replace</code></td><td>如果存在同名文章，将其替换</td></tr><tr><td><code>-s</code>, <code>--slug</code></td><td>文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><pre class=" language-bash"><code class="language-bash">$ hexo new page --path about/me <span class="token string">"About me"</span></code></pre><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>"About me"</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><pre class=" language-bash"><code class="language-bash">$ hexo new page --path about/me</code></pre><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>"page"</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h3 id="启动本地测试服务器"><a href="#启动本地测试服务器" class="headerlink" title="启动本地测试服务器"></a>启动本地测试服务器</h3><pre class=" language-bash"><code class="language-bash">$ hexo s --debug </code></pre><h3 id="构建并部署"><a href="#构建并部署" class="headerlink" title="构建并部署"></a>构建并部署</h3><pre class=" language-bash"><code class="language-bash">$ hexo g -d</code></pre><p>等同于</p><pre class=" language-bash"><code class="language-bash">$ hexo generate$ hexo deploy</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="HEXO-程序配置"><a href="#HEXO-程序配置" class="headerlink" title="HEXO 程序配置"></a>HEXO 程序配置</h3><h3 id="NEXT-主题配置"><a href="#NEXT-主题配置" class="headerlink" title="NEXT 主题配置"></a>NEXT 主题配置</h3><h3 id="文章分类"><a href="#文章分类" class="headerlink" title="文章分类"></a>文章分类</h3><h2 id="变更记录"><a href="#变更记录" class="headerlink" title="变更记录"></a>变更记录</h2><h3 id="配置完成"><a href="#配置完成" class="headerlink" title="配置完成"></a>配置完成</h3><!-- markdownlint-disable MD041 MD002--><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试hexo同步</title>
      <link href="2020/10/01/yuque/ce-shi-hexo-tong-bu/"/>
      <url>2020/10/01/yuque/ce-shi-hexo-tong-bu/</url>
      
        <content type="html"><![CDATA[<p>测试 hexo 同步，仅作测试解决 dada dasd</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决DDNS解析问题，实现公网访问群晖</title>
      <link href="2020/06/18/yuque/jie-jue-ddns-jie-xi-wen-ti-shi-xian-gong-wang-fang-wen-qun-hui/"/>
      <url>2020/06/18/yuque/jie-jue-ddns-jie-xi-wen-ti-shi-xian-gong-wang-fang-wen-qun-hui/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文内容仅适用于群晖，若应用在其他地方，请自行修改。<br>本文是基于阿里云的域名解析实现的，使用群晖的 <strong>计划任务</strong>&nbsp;+ <code>sh</code>&nbsp; 脚本来实现 DDNS 功能，理论上支持 <code>IPV4</code>&nbsp; 和 <code>IPV6</code>&nbsp;，因为个人条件有限，未拥有公网的 <code>IPV4</code>&nbsp; 的地址，所以未针对 <code>IPV4</code>&nbsp; 进行测试。若有问题，也可以留言一起讨论。<br>目前网络上的基于 <code>sh</code> 脚本的方式实现 <code>DDNS</code> 的代码在我的环境中都已失效，怀疑是群晖版本问题。不想用 <code>docker</code>&nbsp; 或其他方式实现 DDNS 功能(嫌麻烦)，所以我用三脚猫的水平，基于<a target="_blank" rel="noopener" href="https://github.com/jwping/AliDDNS">jwping/AliDDNS</a>&nbsp; 的代码完成了我的目的。目前在我机器上正常工作。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/87319/1592472673921-8f79581e-798d-495d-a7c1-86cc60638634.png#align=left&amp;display=inline&amp;height=300&amp;margin=%5Bobject%20Object%5D&amp;name=DDNS%E4%BF%AE%E6%94%B9%E8%AE%B0%E5%BD%95.png&amp;originHeight=590&amp;originWidth=820&amp;size=68833&amp;status=done&amp;style=none&amp;width=417" alt="DDNS修改记录.png"></p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>硬件：七彩虹 <code>C.J3160M-K 全固态版 V21</code>&nbsp; 主板，板载了 intel 的 J3160 处理器</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/87319/1592472562781-aafae61a-2bbb-4e32-ba5a-2039ce6a74fd.jpeg#align=left&amp;display=inline&amp;height=200&amp;margin=%5Bobject%20Object%5D&amp;name=C.J3160M-K%20%E5%85%A8%E5%9B%BA%E6%80%81%E7%89%88%20V21.jpg&amp;originHeight=800&amp;originWidth=800&amp;size=167589&amp;status=done&amp;style=none&amp;width=200" alt="C.J3160M-K 全固态版 V21.jpg"></p><ul><li>系统：黑群晖 <code>DSM 6.2.3</code>&nbsp; 版本</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/87319/1592472576763-8071aed8-62a7-415d-85fb-7467e42bc28a.png#align=left&amp;display=inline&amp;height=200&amp;margin=%5Bobject%20Object%5D&amp;name=%E9%BB%91%E7%BE%A4%E6%99%96%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%88%AA%E5%9B%BE.png&amp;originHeight=495&amp;originWidth=719&amp;size=21403&amp;status=done&amp;style=none&amp;width=291" alt="黑群晖系统信息截图.png"></p><h2 id="代码配置"><a href="#代码配置" class="headerlink" title="代码配置"></a>代码配置</h2><p>完整代码请查看 GitHub：<a target="_blank" rel="noopener" href="https://github.com/wudision0416/aliddns4dsm">wudision0416/aliddns4dsm</a></p><h3 id="1-修改基础配置"><a href="#1-修改基础配置" class="headerlink" title="1. 修改基础配置"></a>1. 修改基础配置</h3><p>修改脚本的<code>ipv4</code>或<code>ipv6</code>函数，其中 <code>DomainRecordId</code>&nbsp; 不清楚的话暂时不用修改，如:</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#Accesskey在开头Setting代码段中修改。</span>AccessKeyId<span class="token operator">=</span><span class="token string">"MyID"</span>AccessKeySec<span class="token operator">=</span><span class="token string">"MySecret"</span></code></pre><p>此处的 DNS 解析服务器为万网，如无特殊需求可以不做修改。</p><pre class=" language-bash"><code class="language-bash">DNSServer<span class="token operator">=</span><span class="token string">"dns9.hichina.com"</span></code></pre><p>主要的参数都在在尾部<code>ipv4</code>或<code>ipv6</code>的函数调用中修改。<br><code>DomainRR</code>&nbsp; 为需要监控的二级域名；<br><code>DomainName</code>&nbsp; 为需要监控的域名；<br><code>DomainType</code>&nbsp; 是解析类型， <code>A</code>&nbsp; 是 IPV4 解析，而 <code>AAAA</code>&nbsp; 是 IPV6 解析，默认不用修改<br><code>dev</code>&nbsp; 是群晖目标网卡的名称，可以启用 SSH 功能后，登录使用 <code>ifconfig</code>&nbsp; 命令查看，要准确填写外网访问的网卡名称；<br><code>NslookupDrefix</code>&nbsp; 用于截取域名记录的 IP 地址时 <code>ipv4</code>&nbsp; 和 <code>ipv6</code>&nbsp; 的区分。在群晖中，不支持 <code>dig</code>&nbsp; 方式查询域名地址，所以我直接用了 <code>nslookup</code>&nbsp; 来查询域名解析地址，而 <code>NslookupDrefix</code>&nbsp; 就是结果的关键字前缀，如果有需要，可以参照实际修改。</p><pre class=" language-bash"><code class="language-bash">DomainRecordId<span class="token operator">=</span><span class="token string">"00000"</span>DomainRR<span class="token operator">=</span><span class="token string">"www"</span>DomainName<span class="token operator">=</span><span class="token string">"example.com"</span>DomainType<span class="token operator">=</span><span class="token string">"A"</span>dev<span class="token operator">=</span><span class="token string">"ovs_eth0"</span>NslookupDrefix<span class="token operator">=</span><span class="token string">"Address: "</span></code></pre><h3 id="2-查看-DomainRecordId"><a href="#2-查看-DomainRecordId" class="headerlink" title="2. 查看 DomainRecordId"></a>2. 查看 DomainRecordId</h3><p>如果不清楚 <code>DomainRecordId</code>&nbsp; 的话，修改 <code>ipv4</code>&nbsp; 或 <code>ipv6</code>&nbsp; 函数，在里面调用 <code>describe_record</code>&nbsp;，如：</p><pre class=" language-bash"><code class="language-bash">ipv6<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span> describe_record <span class="token comment" spellcheck="true">#update_record</span>    <span class="token punctuation">}</span></code></pre><p>然后执行这个脚本。如果没问题的话，就能获取到域名的所有解析记录的列表了：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"PageNumber"</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token property">"TotalCount"</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token property">"PageSize"</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token property">"RequestId"</span><span class="token operator">:</span><span class="token string">"0000"</span><span class="token punctuation">,</span><span class="token property">"DomainRecords"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token property">"Record"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"RR"</span><span class="token operator">:</span><span class="token string">"www"</span><span class="token punctuation">,</span><span class="token property">"Status"</span><span class="token operator">:</span><span class="token string">"ENABLE"</span><span class="token punctuation">,</span><span class="token property">"Value"</span><span class="token operator">:</span><span class="token string">"8.8.8.8"</span><span class="token punctuation">,</span> <span class="token property">"RecordId"</span><span class="token operator">:</span><span class="token string">"21332133"</span><span class="token punctuation">,</span><span class="token property">"Type"</span><span class="token operator">:</span><span class="token string">"A"</span><span class="token punctuation">,</span><span class="token property">"DomainName"</span><span class="token operator">:</span><span class="token string">"example.com"</span><span class="token punctuation">,</span> <span class="token property">"Locked"</span><span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token property">"Line"</span><span class="token operator">:</span><span class="token string">"default"</span><span class="token punctuation">,</span><span class="token property">"TTL"</span><span class="token operator">:</span><span class="token string">"600"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">}</span> <span class="token punctuation">}</span>HttpCode<span class="token operator">:</span><span class="token number">200</span></code></pre><p>上面的结果中， <code>RecordId</code>&nbsp; 为 <strong>21332133</strong>&nbsp;。得到结果后再修改 <code>DomainRecordId</code>&nbsp; 为正确的值。</p><h3 id="3-执行脚本"><a href="#3-执行脚本" class="headerlink" title="3. 执行脚本"></a>3. 执行脚本</h3><p>基础配置完成后，改回原入口函数：</p><pre class=" language-bash"><code class="language-bash">ipv6<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">#describe_record</span> update_record    <span class="token punctuation">}</span></code></pre><p>执行脚本即可，脚本会在本机 IP 地址和当前域名解析设置不同的时候调用 API 更新设置。</p><h3 id="4-选择执行函数"><a href="#4-选择执行函数" class="headerlink" title="4. 选择执行函数"></a>4. 选择执行函数</h3><p>如下选择需要执行的函数，我因为没有 <code>IPV4</code>&nbsp;，所以只启用了 <code>IPV6</code></p><pre class=" language-bash"><code class="language-bash">ipv6<span class="token comment" spellcheck="true">#ipv4</span></code></pre><h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h3><p>有关于日志输出的一些参数配置，直接看脚本就可明了，如果需要查看日志，请在群晖设置计划任务是设置日志的输出路径，详细请参考网上其他教程即可。</p><h2 id="设置计划任务"><a href="#设置计划任务" class="headerlink" title="设置计划任务"></a>设置计划任务</h2><p>这一步就是在群晖的控制面板上设置相应的计划任务，参考网上的即可，主要目的是以一定的频率执行上诉脚本任务，</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我们为何要写作</title>
      <link href="2019/10/19/wo-men-wei-he-yao-xie-zuo/"/>
      <url>2019/10/19/wo-men-wei-he-yao-xie-zuo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载来源：<a target="_blank" rel="noopener" href="https://blog.devtang.com/">唐巧的博客</a><br>原文：<a target="_blank" rel="noopener" href="https://blog.devtang.com/2014/01/08/why-we-need-write/">为码农，我们为什么要写作</a><br>作者：唐巧<br>转载时间：2019年10月19日</p></blockquote><hr><p>在程序员这个行业，坚持做技术写作的人一直比较少。我和身边的朋友沟通后，发现他们除了借口没有时间外，大多没有意识到写作带来的收益。在他们看来，将自己学到的知识简单记录下来就足够自己需要的时候回顾了。而技术写作通常需要花更多时间，因为需要将技术的细节以及来龙去脉讲清楚。</p><p>不得不承认，这的确是一个事实，通常情况下，把一个知识讲清楚比理解它更难。那我们为什么要花时间写作呢？我想写作至少有以下好处。</p><h2 id="提高自己对知识的掌握层次"><a href="#提高自己对知识的掌握层次" class="headerlink" title="提高自己对知识的掌握层次"></a>提高自己对知识的掌握层次</h2><p>美国教育心理学家 <a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E6%9C%AC%E5%82%91%E6%98%8E%C2%B7%E5%B8%83%E9%AD%AF%E5%A7%86">Bloom</a> 将知识认知分为了两个维度，其中认知历程维度又分为 6 个层次，分别为：记忆、理解、应用、分析、评鉴、创造。如下图所示，层次越高，表示对知识的掌握程度越深。</p><p><img src="https://blog.devtang.com/images/why-write-1.png"></p><p>对于写作者来说，在写作过程中，因为需要对知识进行精确地表述，常常要对知识的细节再次的探索。在这个过程中，写作者可能会发现自己的观点不清晰的地方，通过二次学习，使自己的理解更加完善。写作者也可能会发现自己观点中的错误，从而改正自己的曲解。在经历过这段过程后，通常对于自己所写的知识的掌握程度，都上升了一个层次。</p><p>我自己的每次技术写作都经历了这样的提高过程。所以，我更多时候是把写作当成学习的一种方式。这种学习方式比普通的学习方式更加深入，效果更好。当然，花费的时间也更多。</p><h2 id="提高表达和沟通的能力"><a href="#提高表达和沟通的能力" class="headerlink" title="提高表达和沟通的能力"></a>提高表达和沟通的能力</h2><p>作为一个程序员，日常的工作大部分时间都是面对电脑。许多人周末也喜欢当一个技术宅，待在家里上网、看电影或者玩游戏来消遣。长时间的面对机器，使得我们的语言表达能力极度衰退。而写作是一个很好的机会，让我们练习自己的表达能力。</p><p>长时间写作之后，你会更加注意平时沟通的语言。你的用词更加精准，表达更加生动。在表达能力提高的同时，你的沟通效率也得到提高。</p><h2 id="接受读者的沟通和反馈"><a href="#接受读者的沟通和反馈" class="headerlink" title="接受读者的沟通和反馈"></a>接受读者的沟通和反馈</h2><p>当你的文章通过博客或者 <code>InfoQ</code> 网站发表出来后，你就会接着获得写作的第三个好处：来自读者的沟通和反馈。一篇好的文章通常会吸引一些读者回复，通过和读者的交流，你可以收获以下好处：</p><ol><li><p>错误内容反馈：尽管文章在写作时经历过二次学习，但是人难免会犯错。写作将你的思想完全暴露出来，有水平的读者可以指出你文章中的错误，从而使你对知识的理解更加准确。我的很多博客文章都有一些细微错误，通过读者的找反馈，我很快就将错误内容改正过来了，自己的水平也得到了提高。</p></li><li><p>认识朋友：一个乐于分享的人总会比沉默寡言的人更招人喜欢。所以通过写作，你可以结交很多和你一样，乐于分享的朋友。</p></li><li><p>了解更多相关信息：一些读者会回复说：” 某某框架也用了这个技术方案 “，或者是：” 你的这个实现方案没有另一个某某开源方案好 “。这些信息，作为你当前文章知识点的补充，使你能够了解更多相关的资料，再一次完善自己所学的知识。</p></li></ol><h2 id="影响力"><a href="#影响力" class="headerlink" title="影响力"></a>影响力</h2><p>当你持续的写作，坚持一年以上，你就会慢慢收获影响力。这个时候，你也会收到技术大会的分享邀请，出版社的约稿邀请，著名互联网公司的工作邀请，甚至是创业项目的合伙人邀请。你相比那些不分享的人，获得了更多的机会。当然你的技术观点也会被更多人接受，你也会收获到传递知识的乐趣。</p><p>#结束语</p><p>在写作过程中，你将收获<code>提高自己对知识的掌握层次</code>和<code>提高表达和沟通的能力</code>的好处。<br>在写作结束后，你将收获<code>错误内容反馈</code>、<code>认识朋友</code>和<code>了解更多相关信息</code>的好处。<br>在坚持写作一段时间，你将收获<code>影响力</code>和<code>传递知识的乐趣</code>。<br>另外，<a target="_blank" rel="noopener" href="http://book.douban.com/subject/6709809/">《暗时间》</a> 的作者刘未鹏在 <a target="_blank" rel="noopener" href="http://blog.csdn.net/pongba/article/details/3896311">他的文章</a>，也总结了很多写作的好处，大家也可以看看。<br>看了写作的这么多好处，你是否心动？那赶快创建一个博客，开始你的技术写作之旅吧！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 写作 </tag>
            
            <tag> 鸡血 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何规划博客的标签和分类</title>
      <link href="2019/10/19/ru-he-gui-hua-bo-ke-de-biao-qian-he-fen-lei/"/>
      <url>2019/10/19/ru-he-gui-hua-bo-ke-de-biao-qian-he-fen-lei/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载来源：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/holbrook/">心内求法@博客园</a><br>原文：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/holbrook/archive/2012/11/05/2755268.html">何规划blog的标签（tag）和分类</a><br>作者：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/holbrook/">心内求法</a><br>转载时间：2019年10月19日</p></blockquote><hr><p>在<a target="_blank" rel="noopener" href="http://www.cnblogs.com/holbrook/archive/2012/11/04/2753533.html">《IT 人员如何管理知识》</a> 中提到了应该构建并定期重构自己的知识地图。作为一种 “写作式学习” 的有效手段，<code>blog</code> 也应该纳入个人知识管理的范畴。那么，如何将知识地图映射到 <code>blog</code> 的分类和标签，使得 <code>blog</code> 文章的管理更加有效呢？</p><h2 id="1-分类和标签"><a href="#1-分类和标签" class="headerlink" title="1 分类和标签"></a>1 分类和标签</h2><p>大多数的 <code>blog</code> 站点都支持按照分类和标签对文章进行组织。这也是信息管理的两种有效手段。二者的对比如下：</p><table><thead><tr><th></th><th>分类</th><th>标签</th></tr></thead><tbody><tr><td>排他性</td><td>是</td><td>否</td></tr><tr><td>关系</td><td>从属</td><td>相关 (关联）</td></tr><tr><td>创建</td><td>事先规划</td><td>随时增加</td></tr><tr><td>代价</td><td>高</td><td>低</td></tr></tbody></table><p>分类是最经典的方法，事先进行严格的类别划分，构建分类树，然后每个项目 (<code>Item</code>) 从属于分类树上的唯一节点。 由于类别的划分比较严格，通常会在一开始就规划好。如果想要更改分类树，就要付出比较大的代价。</p><p>标签 (<code>tag</code>) 是比较新兴的一种信息管理方式。与分类最大的不同是每个项目 (<code>Item</code>) 可以有多个标签。标签之间没有关系，但是通过内容可以使不同的标签之间产生关联。 如果某个项目（<code>Item</code>)具有多个标签，那么这多个标签之间就产生了某种相关性。相关性可以表达任何一种关系，可以用相关性表示出一颗分类树，也可以表示出一张图（<code>Graph</code>）。 增加标签的代价非常小，完全可以在产生项目（<code>Item</code>）之后再按需增加标签，并通过关联使新的标签与原来的标签之间产生相关性关系。</p><p>由于标签更加灵活强大，变更的代价又很小，在很多同时支持分类和标签的系统或软件工具中都在逐步淡化分类的作用。比如，gmail 中的分类功能就是用标签实现的；evernote 中的笔记本只支持两级划分（笔记本组和笔记本）；博客园的博客系统只支持一级分类。</p><h2 id="2-构建博客的标签地图"><a href="#2-构建博客的标签地图" class="headerlink" title="2 构建博客的标签地图"></a>2 构建博客的标签地图</h2><p>由于标签的灵活性，完全可以用标签表示出你的整个<a target="_blank" rel="noopener" href="http://www.cnblogs.com/holbrook/archive/2012/11/04/2753533.html#sec-4">知识地图</a>。</p><p>因为通常博客不支持图片上的热区，而且图片的编辑比较麻烦，所以最好能够用<code>文本/html</code>的方式表示出来。我的建议是将各种<a target="_blank" rel="noopener" href="http://www.cnblogs.com/holbrook/archive/2012/11/04/2753533.html#sec-3">条理</a> 都整理出来，加上博客标签的链接，作为单独的一篇文章并置顶，专门用于导航。 比如我刚刚整理出来的这样：</p><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/holbrook/archive/2012/11/05/2755127.html" title="我的博客导航"><img src="https://pic002.cnblogs.com/images/2012/376709/2012110515461829.png"></a></p><h2 id="3-关于博客分类"><a href="#3-关于博客分类" class="headerlink" title="3 关于博客分类"></a>3 关于博客分类</h2><p>尽管通过标签已经可以不使用博客分类了，但是为了方便读者，或者为了遵循某些旧的习惯，还是可以使用一个简单的分类。这里简单的意思是做一个比较粗的分类即可，比如我是这样划分的：</p><ol><li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/holbrook/category/425930.html">域. 业务领域</a> &nbsp;  </li><li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/holbrook/category/425929.html">术. 解决方案</a> &nbsp;  </li><li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/holbrook/category/425928.html">技. 技术研究</a></li><li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/holbrook/category/425927.html">阵. 技术应用</a></li><li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/holbrook/category/425926.html">法. 手段方法</a></li><li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/holbrook/category/425924.html">理. 理论学习</a></li><li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/holbrook/category/425923.html">器. 工具使用</a><br>A. <a target="_blank" rel="noopener" href="http://www.cnblogs.com/holbrook/category/363809.html">杂. 杂七杂八</a></li></ol><p>这样粗线条的划分的好处是分类会比较稳定，毕竟更新分类比起添加 <code>tag</code> 要麻烦很多。</p><h2 id="4-使用标签和分类"><a href="#4-使用标签和分类" class="headerlink" title="4 使用标签和分类"></a>4 使用标签和分类</h2><p>当你新写一篇文章的时候，首先要选择一个分类，然后将所有相关的 <code>tag</code> 都加上，包括 <code>tag</code> 在树上的所有路径。 比如按照我的 <code>tag</code> 划分，本文的标签包括：</p><p>  业务解决方案，知识管理<br>  方法论，个人知识管理<br>  工具，博客</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 手段方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章分类 </tag>
            
            <tag> 知识管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用 Frp 实现内网穿透并问群晖 NAS</title>
      <link href="2019/10/16/li-yong-frp-shi-xian-nei-wang-chuan-tou-bing-wen-qun-hui-nas/"/>
      <url>2019/10/16/li-yong-frp-shi-xian-nei-wang-chuan-tou-bing-wen-qun-hui-nas/</url>
      
        <content type="html"><![CDATA[<p>服务器：阿里云Ubuntu 16.04；<br>NAS：黑群晖 6.1.x;<br>Frp: v0.18.0</p><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>因不可名状的原因，在家搭建了一台黑群晖。NAS有外网访问的需求，但家里的宽带运营商是移动的，公网IP无望，所以动态DNS方案不适用，只能考虑内网穿透。<br>内网穿透技术比较流行的应该是<code>花生壳</code>、<code>Ngrok</code>、<code>Frp</code>。花生壳免费版是鸡肋，首先Pass，<code>Ngrok</code>相对成熟，但配置繁琐，也Pass了，那就选择<code>Frp</code>。<code>Frp</code>不得了，配置简单，跨平台，看到第一眼就喜欢上了。</p><h2 id="1-前提条件"><a href="#1-前提条件" class="headerlink" title="1 前提条件"></a>1 前提条件</h2><ol><li>拥有公网IP的服务器：因为国外VPS访问速度的原因，仅作梯子用。在内网穿透上，选择了阿里云的ECS。</li><li>一台NAS：原本购入<code>DS218</code>，因性价比原因，出掉了<code>DS218</code>，闲鱼上买了含CPU的主板和电源机箱，结合自身已有的配件，搭建黑群晖(黑白群晖区别在使用上各取所需就好，综合自身原因，黑群晖更为划算。因常年开机，千万注意功耗！)。</li></ol><h2 id="2-基本步骤"><a href="#2-基本步骤" class="headerlink" title="2 基本步骤"></a>2 基本步骤</h2><p><code>Frp</code>的<a target="_blank" rel="noopener" href="https://github.com/fatedier/frp">项目主页</a>已经给出十分详细的使用文档，若有疑问或冲突，请以官方文档为准。</p><h3 id="2-1-服务器端配置"><a href="#2-1-服务器端配置" class="headerlink" title="2.1 服务器端配置"></a>2.1 服务器端配置</h3><p>本身已购买阿里云的ECS的入门套餐，操作系统选择了自己较为熟悉的<code>Ubuntu 16.04</code>。</p><h4 id="2-1-1-安装软件并配置参数"><a href="#2-1-1-安装软件并配置参数" class="headerlink" title="2.1.1 安装软件并配置参数"></a>2.1.1 安装软件并配置参数</h4><p>对于软件的安装(其实是将<code>Frp</code>程序弄到目标路径中)一般有两种方式：</p><h5 id="2-1-1-1-服务器端软件下载并配置相关参数"><a href="#2-1-1-1-服务器端软件下载并配置相关参数" class="headerlink" title="2.1.1.1 服务器端软件下载并配置相关参数"></a>2.1.1.1 服务器端软件下载并配置相关参数</h5><ol><li>登录服务器，在 <a target="_blank" rel="noopener" href="https://github.com/fatedier/frp/releases">Release页面</a> 下载自己服务器对应版本的 <code>Frp</code>。</li></ol><pre class=" language-BASH"><code class="language-BASH">$ wget https://github.com/fatedier/frp/releases/download/v0.18.0/frp_0.18.0_linux_amd64.tar.gz</code></pre><p>我 ECS 是<code>Ubuntu 16.04</code>64位操作系统，所以选择了<code>linux_amd64</code>，Frp选择了此时最新的<code>v0.18.0</code>。压缩包内包含了服务器和客户端的所有文件。</p><ol start="2"><li>使用 <code>tar</code> 指令解压 <code>tar.gz</code> 文件</li></ol><pre class=" language-bash"><code class="language-bash">$ <span class="token function">tar</span> -zxvf frp_0.18.0_linux_amd64.tar.gz</code></pre><ol start="3"><li>进入 <code>frp</code> 目录</li></ol><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> frp_0.18.0_linux_amd64</code></pre><ol start="4"><li>删除不必要的客户端文件</li></ol><pre class=" language-bash"><code class="language-bash">$ <span class="token function">rm</span> -f frpc frpc_full.ini frpc.ini</code></pre><blockquote><p>版本不同可能内含文件稍有差异。</p></blockquote><p><code>frpc</code> 为客户端运行文件，<code>frpc.ini</code>为客户端配置文件，<code>frps</code> 为服务器端运行文件，<code>frps.ini</code> 为服务器端配置文件。</p><ol start="5"><li>配置服务器端文件<br>输入命令</li></ol><pre class=" language-bash"><code class="language-bash">$ <span class="token function">vi</span> frps.ini</code></pre><p>修改配置文件</p><pre><code>[common]bind_port = 7000bind_udp_port = 7001vhost_http_port = 8080vhost_https_port = 7433dashboard_port = 7500dashboard_user = 用户名dashboard_pwd = 密码authentication_timeout = 900  </code></pre><p>简单释义：</p><blockquote><p>[common] 必填，公共参数<br>bind_port Frp 服务端与客户端TCP通信端口（可自定义）<br>bind_udp_port Frp 服务端与客户端UDP通信端口（可自定义）<br>vhost_http_port 客户端的 http 访问端口（可自定义）<br>vhost_https_port 客户端的 https 访问端口（可自定义）<br>dashboard_port 访问 dashboard 界面端口 (dashboard 是 frp 的信息web展示。)<br>dashboard_user 登录 dashboard 用户名<br>dashboard_pwd 登录 dashboard 密码<br>max_pool_count 最大连接池数量<br>authentication_timeout 超时验证时间</p></blockquote><p>详细配置请参考官方文档。</p><p><a target="_blank" rel="noopener" href="https://github.com/fatedier/frp/blob/master/README_zh.md">官方文档</a></p><ol start="6"><li>保存上面配置文件，进入<code>frp</code>目录并启动 <code>frps</code> 程序。未列出切换目录的命令，如果没有变动目录直接运行即可。</li><li><pre class=" language-bash"><code class="language-bash">$ ./frps -c ./frps.ini</code></pre></li></ol><p>*请注意文件的权限，是否有可执行权限，开机自启动在 配置服务器 中。</p><h5 id="2-1-1-2-PC端下载，配置完成后上传至服务器的目标路径中。"><a href="#2-1-1-2-PC端下载，配置完成后上传至服务器的目标路径中。" class="headerlink" title="2.1.1.2 PC端下载，配置完成后上传至服务器的目标路径中。#####"></a>2.1.1.2 PC端下载，配置完成后上传至服务器的目标路径中。#####</h5><blockquote><p>因为个人水平习惯等因素，我还是喜欢用这种方式，将压缩包直接下载到磁盘路径中，按需求修改配置文件，然后将所需文件上传至服务器目标路径中，修改文件权限。然后启动<code>frps</code>程序。</p></blockquote><h4 id="2-1-2-配置服务器"><a href="#2-1-2-配置服务器" class="headerlink" title="2.1.2 配置服务器"></a>2.1.2 配置服务器</h4><h5 id="2-1-2-1-在防火墙或云服务安全组策略中开放相关端口"><a href="#2-1-2-1-在防火墙或云服务安全组策略中开放相关端口" class="headerlink" title="2.1.2.1 在防火墙或云服务安全组策略中开放相关端口"></a>2.1.2.1 在防火墙或云服务安全组策略中开放相关端口</h5><p>系统可能自带防火墙，且只开放了常用端口，如果有防火墙，你需要检查是否已正确开放端口。<br>阿里云的ECS在控制台有默认的安全组策略，就类似防火墙作用，如果你的云服务商也默认使用类似功能，请确保已正确的配置相关端口的安全组策略。详细操作参考云服务商资料。</p><h5 id="2-1-2-2-使用-Nginx-等软件隐藏非-web-访问默认端口"><a href="#2-1-2-2-使用-Nginx-等软件隐藏非-web-访问默认端口" class="headerlink" title="2.1.2.2 使用 Nginx 等软件隐藏非 web 访问默认端口"></a>2.1.2.2 使用 Nginx 等软件隐藏非 web 访问默认端口</h5><p><code>http</code>默认使用<code>80</code>端口，而<code>https</code>默认使用<code>443</code>端口,如果服务器上有web程序，<code>nginx</code>等代理软件会占用这些端口。<code>frp</code>就的选择其他的端口进行远程访问，比如上方服务器配置文件中的<code>8080</code>端口。假设我分配了一个子域名<code>nas.chafanzhai.com</code>作为访问NAS的域名，那我需在浏览器输入<code>nas.chafanzhai.com:8080</code>才能正确访问NAS，如果仅输入<code>nas.chafanzhai.com</code>，访问的是<code>80</code>端口，<code>frp</code>是无法监听到的。那怎样才能隐藏<code>8080</code>端口号呢？就是在<code>Nginx</code>中为<code>frp</code>配置反向代理。以下为个人使用的配置文件，酌情修改，仅供参考。</p><pre><code>server {    listen 80;    listen 5000;    server_name nas.chafanzhai.com;    location / {    proxy_pass http://127.0.0.1:8080;    proxy_set_header Host $host;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header X-Forwarded-Proto $scheme;    }}server {    listen 443;    listen 5001;    ssl on;    ssl_certificate 证书文件的绝对路径;    ssl_certificate_key 证书文件的绝对路径;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_prefer_server_ciphers on;    server_name nas.chafanzhai.com;    location / {    proxy_pass https://nas.chafanzhai.com:7433;    proxy_ssl_server_name on;    proxy_set_header Host $http_host;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header X-Forwarded-Proto $scheme;    }}</code></pre><blockquote><p>几点解释</p><ol><li>对于<code>Nginx</code>配置的参考网络上的许多文章，看过哪些也忘记了，所以没做引用。对于配置参数的意义，请参考<code>nginx</code>相关资料。</li><li>阿里云ECS域名访问要求域名已备案。</li><li>因暴露在广域网下，所以配置了<code>HTTPS</code>，证书申请的阿里云免费证书，<code>HTTPS</code>配置仅供参考，需换成自己证书的绝对路径。</li><li>反向代理同时监听了<code>5000</code>、<code>5001</code>端口，是因为需要支持群晖相关APP的远程访问，浏览器访问时使用web的默认端口，但群晖相关app中无法配置访问端口。具体群晖的服务使用了那些端口，你需要监听那些端口请参考群晖官网的<a target="_blank" rel="noopener" href="https://www.synology.com/zh-cn/knowledgebase/DSM/tutorial/General/What_network_ports_are_used_by_Synology_services">说明文档</a>。</li><li>在搜索中发现一些同学的方向代理不起作用，需要将<code>127.0.0.1</code>替换成服务器的公网IP。我暂未遇到这种情况，列出仅供参考。</li></ol></blockquote><h5 id="2-1-2-3-配置frp服务端开机运行"><a href="#2-1-2-3-配置frp服务端开机运行" class="headerlink" title="2.1.2.3 配置frp服务端开机运行"></a>2.1.2.3 配置frp服务端开机运行</h5><p>用<code>supervisor</code>方法。</p><ol><li>先安装<code>supervisor</code></li></ol><pre class=" language-BASH"><code class="language-BASH">$ sudo apt install supervisor</code></pre><ol start="2"><li>创建 <code>supervisor</code>的<code>frps</code> 配置文件</li></ol><p>在 <code>/etc/supervisor/conf.d</code> 创建 <code>frp.conf</code>，</p><pre><code>[program:frp]command = /usr/local/frps/frps -c /usr/local/frps/frps.iniautostart = true</code></pre><p><code>command</code>应该是你放置<code>frp</code>软件的位置。</p><p>我的 <code>frp</code> 在 <code>/usr/local/frps</code> 这个目录下。</p><ol><li>查看状态</li></ol><pre><code># 重启supervisor$ sudo systemctl restart supervisor# 查看supervisor运行状态$ sudo supervisorctl status</code></pre><h3 id="2-2-客户端配置"><a href="#2-2-客户端配置" class="headerlink" title="2.2 客户端配置"></a>2.2 客户端配置</h3><p>说句题外话，因为我的 CPU 是 AMD 的，开始考虑兼容性问题，一开始装的是<code>5.9</code>版本的黑群晖，应该是我不熟悉的原因，自带的终端太难弄了，果断换成了<code>DSM 6.1</code>。<br>好像群晖默认是不启用 <code>root</code> 账户，所有操作能用 <code>admin</code> 账户 + <code>sudo</code> 来完成。个人自带轻微强迫症，没有 <code>root</code> 账户，无法访问系统的所有路径，这些都不是我想要的安装位置，如果下载在本地磁盘，修改后上传，我还需要修改文件路径。所以我直接下载在NAS上修改配置文件了。</p><h4 id="2-2-1-安装软件并配置参数"><a href="#2-2-1-安装软件并配置参数" class="headerlink" title="2.2.1 安装软件并配置参数"></a>2.2.1 安装软件并配置参数</h4><h5 id="2-2-1-1-登陆到NAS，获取root权限，进入软件目标路径"><a href="#2-2-1-1-登陆到NAS，获取root权限，进入软件目标路径" class="headerlink" title="2.2.1.1 登陆到NAS，获取root权限，进入软件目标路径"></a>2.2.1.1 登陆到NAS，获取<code>root</code>权限，进入软件目标路径</h5><p>输入以下命令</p><pre><code>$ sudo -i</code></pre><p>提示输入密码，只需输入<code>admin</code>账户的密码并可获取<code>root</code>权限，在进入目标路径。</p><pre><code>$ cd /usr/local</code></pre><h5 id="2-2-1-2-下载frp的目标版本"><a href="#2-2-1-2-下载frp的目标版本" class="headerlink" title="2.2.1.2 下载frp的目标版本"></a>2.2.1.2 下载<code>frp</code>的目标版本</h5><p>群晖是基于<code>linux</code>的，但请注意你的 cpu 指令集类型，我的是黑群晖,当然还是<code>linux_amd64</code>啦。</p><pre><code>$ wget https://github.com/fatedier/frp/releases/download/v0.18.0/frp_0.18.0_linux_amd64.tar.gz</code></pre><h5 id="2-2-1-3-使用-tar-指令解压-tar-gz-文件"><a href="#2-2-1-3-使用-tar-指令解压-tar-gz-文件" class="headerlink" title="2.2.1.3 使用 tar 指令解压 tar.gz 文件"></a>2.2.1.3 使用 <code>tar</code> 指令解压 <code>tar.gz</code> 文件</h5><pre><code>$ tar -zxvf frp_0.18.0_linux_amd64.tar.gz</code></pre><h5 id="2-2-1-4-重命名目录，并删除压缩包-强迫症作祟"><a href="#2-2-1-4-重命名目录，并删除压缩包-强迫症作祟" class="headerlink" title="2.2.1.4 重命名目录，并删除压缩包(强迫症作祟)"></a>2.2.1.4 重命名目录，并删除压缩包(强迫症作祟)</h5><pre><code>$ mv frp_0.18.0_linux_amd64 frpc$ rm frp_0.18.0_linux_amd64.tar.gz</code></pre><h5 id="2-2-1-5-进入-frp-目录"><a href="#2-2-1-5-进入-frp-目录" class="headerlink" title="2.2.1.5 进入 frp 目录"></a>2.2.1.5 进入 <code>frp</code> 目录</h5><pre><code>$ cd frpc</code></pre><h5 id="2-2-1-6-删除不必要的服务端文件"><a href="#2-2-1-6-删除不必要的服务端文件" class="headerlink" title="2.2.1.6 删除不必要的服务端文件"></a>2.2.1.6 删除不必要的服务端文件</h5><pre><code>$ rm -f frps frps_full.ini frps.ini</code></pre><h5 id="2-2-1-7-配置服务器端文件"><a href="#2-2-1-7-配置服务器端文件" class="headerlink" title="2.2.1.7 配置服务器端文件"></a>2.2.1.7 配置服务器端文件</h5><p>输入命令</p><pre><code>$ vi frps.ini</code></pre><p>修改配置文件</p><pre><code>[common]server_addr = 服务器IPserver_port = 7000# 客户端热加载配置文件admin_addr = 127.0.0.1admin_port = 7400[nas]type = httplocal_port = 5000custom_domains = nas.chafanzhai.com[nass]type = httpslocal_port = 5001custom_domains = nas.chafanzhai.com</code></pre><p>意义和上面服务器配置的差不多，主要多了个<code>admin_addr</code>选项用于客户端热加载配置文件的，对于<code>http</code>和<code>https</code>的端口，需要使用群晖默认的端口，如果是其他自定义的<code>web</code>程序需要暴露在公网下，记得在群晖的<code>Web Station</code>中配置相关端口噢。</p><h4 id="2-2-2-设置开机自启动"><a href="#2-2-2-设置开机自启动" class="headerlink" title="2.2.2 设置开机自启动"></a>2.2.2 设置开机自启动</h4><h5 id="2-2-2-1-创建脚本文件"><a href="#2-2-2-1-创建脚本文件" class="headerlink" title="2.2.2.1 创建脚本文件"></a>2.2.2.1 创建脚本文件</h5><ol><li>新建脚本文件</li></ol><pre><code>$ vi /usr/syno/etc.defaults/rc.sysv/S99frp.sh</code></pre><ol><li>编辑脚本内容</li></ol><pre><code>#/bin/bash$ cd /usr/local/frpc$ nohup ./frpc -c ./frpc.ini &amp;</code></pre><ol start="3"><li>设置文件权限</li></ol><pre><code>$ chmod +x /usr/syno/etc.defaults/rc.sysv/S99frp.sh</code></pre><h5 id="2-2-2-2-设置自启动"><a href="#2-2-2-2-设置自启动" class="headerlink" title="2.2.2.2 设置自启动"></a>2.2.2.2 设置自启动</h5><ol><li><p>登录群晖 NAS 系统</p></li><li><p>进入<code>控制面板</code>的<code>计划任务</code>中</p></li><li><p>创建一个<code>触发的任务</code> -&gt; <code>用户定义的脚本</code>，参数设置如下：</p></li></ol><pre><code>常规设置名称名称，如：frp auto start用户账号：root事件：开机</code></pre><p><img src="https://chafanzhai-com.oss-cn-shanghai.aliyuncs.com/img/2732919655.jpg" alt="一张非常稀有的图片"></p><ol start="4"><li>任务设置</li></ol><p>用户定义的脚本，填入上面创建的脚本</p><pre><code>/usr/syno/etc.defaults/rc.sysv/S99frp.sh</code></pre><p><img src="https://chafanzhai-com.oss-cn-shanghai.aliyuncs.com/img/2075144557.jpg" alt="另一张非常稀有的图片"></p><p>好了，到此为止所有操作已实施，如果你需要<code>frp</code>更丰富的功能，请配合官方文档服用。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NAS </tag>
            
            <tag> 群晖 </tag>
            
            <tag> frp </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人元器件封装库设计规范</title>
      <link href="2019/10/16/ge-ren-yuan-qi-jian-feng-zhuang-ku-she-ji-gui-fan/"/>
      <url>2019/10/16/ge-ren-yuan-qi-jian-feng-zhuang-ku-she-ji-gui-fan/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>说明：</strong>在参考网络资料后，编辑修改供个人开发生产所用;<br><strong>适用平台：</strong>Altium Designer;<br><strong>版本：</strong>A/0;<br><strong>修订记录：</strong></p><ol><li>版本号：A/0；变更：新建</li></ol></blockquote><hr><h2 id="一、库文件管理"><a href="#一、库文件管理" class="headerlink" title="一、库文件管理"></a>一、库文件管理</h2><h3 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.目的</h3><p>本文档规定设计中需要注意的一些事项，目的是使设计规范化，并通过将经验固化为规范的方式，为个人项目开发提供完整、规范、统一的电子元器件图形符号和封装库，从而实现节省设计时间，缩短产品研发周期，降低设计差错率，提高电路设计水平的目的。</p><h3 id="2-库管理方式"><a href="#2-库管理方式" class="headerlink" title="2.库管理方式"></a>2.库管理方式</h3><ol><li>框架结构：分为原理图元件库和 PCB 元件库两个库,每个库做为一个单独的设计项目。</li><li>库分为标准库和临时库。标准库为已经批量使用的元件库，进行定期更新。临时库为实验中新元件临时存放库，采用实时更新。</li><li>所有库文件放于网盘指定位置，便于同步修改及使用。</li><li>对于首次使用器件，先按规范创建加入临时库中，生产验证后再归类到标准库。</li></ol><h2 id="二、原理图元件建库规范"><a href="#二、原理图元件建库规范" class="headerlink" title="二、原理图元件建库规范"></a>二、原理图元件建库规范</h2><h3 id="1-原理图元件库分类及命名"><a href="#1-原理图元件库分类及命名" class="headerlink" title="1.原理图元件库分类及命名"></a>1.原理图元件库分类及命名</h3><p>依据元器件种类分类(一律采用大写字母)：</p><h4 id="1-1-RCL-LIB-电阻电容电感库"><a href="#1-1-RCL-LIB-电阻电容电感库" class="headerlink" title="1.1 RCL.LIB(电阻电容电感库)"></a>1.1 RCL.LIB(电阻电容电感库)</h4><table><thead><tr><th>元件种类</th><th>简称</th><th>命名</th></tr></thead><tbody><tr><td>普通电阻类：包括 SMD 、碳膜、金膜、氧化膜、绕线、水泥、玻璃釉等</td><td>R</td><td>R</td></tr><tr><td>康铜丝类：包括各种规格康铜丝电阻</td><td>RK</td><td>RK</td></tr><tr><td>排阻：包括独立引脚和公共引脚。A：独立引脚，B:公用一端</td><td>RA</td><td>简称+引脚数+内部电路类型</td></tr><tr><td>热敏电阻类：包括各种规格热敏电阻</td><td>RT</td><td>RT</td></tr><tr><td>压敏电阻类：包括各种规格压敏电阻</td><td>RZ</td><td>RZ</td></tr><tr><td>光敏电阻：包括各种规格光敏电阻</td><td>RL</td><td>RL</td></tr><tr><td>可调电阻类：包括各种规格单路可调电阻</td><td>RV</td><td>简称-电阻数</td></tr><tr><td>无极性电容类：包括各种规格无极性电容</td><td>C</td><td>CAP</td></tr><tr><td>有极性电容类：包括各种规格有极性电容</td><td>C</td><td>CAE</td></tr><tr><td>电感类</td><td>L</td><td>简称+电感数</td></tr><tr><td>变压器类</td><td>T</td><td>简称-型号</td></tr></tbody></table><h4 id="1-2-DQ-LIB-二极管、晶体管库"><a href="#1-2-DQ-LIB-二极管、晶体管库" class="headerlink" title="1.2 DQ.LIB(二极管、晶体管库)"></a>1.2 DQ.LIB(二极管、晶体管库)</h4><table><thead><tr><th>元件种类</th><th>简称</th><th>命名</th></tr></thead><tbody><tr><td>普通二极管类</td><td>D</td><td>D</td></tr><tr><td>稳压二极管类</td><td>DW</td><td>DW</td></tr><tr><td>双向触发二极管类</td><td>D</td><td>简称+型号</td></tr><tr><td>双二极管类：包括<code>BAV99</code></td><td>Q</td><td>D2</td></tr><tr><td>桥式整流器类</td><td>BG</td><td>BG</td></tr><tr><td>三极管类</td><td>Q</td><td>简称-类型</td></tr><tr><td>MOS 管类</td><td>Q</td><td>简称-类型</td></tr><tr><td>IGBT 类</td><td>Q</td><td>IGBT</td></tr><tr><td>单向可控硅(晶闸管)类</td><td>SCR</td><td>简称-型号</td></tr><tr><td>双向可控硅(晶闸管)</td><td>BCR</td><td>简称-型号</td></tr></tbody></table><h4 id="1-3-IC-LIB-集成电路库"><a href="#1-3-IC-LIB-集成电路库" class="headerlink" title="1.3 IC.LIB(集成电路库)"></a>1.3 IC.LIB(集成电路库)</h4><table><thead><tr><th>元件种类</th><th>简称</th><th>命名</th></tr></thead><tbody><tr><td>三端稳压 IC 类:包括 78 系列三端稳压 IC</td><td>U</td><td>简称-型号</td></tr><tr><td>光电耦合器类</td><td>U</td><td>简称-型号</td></tr><tr><td>IC</td><td>U</td><td>简称-型号</td></tr></tbody></table><h4 id="1-4-CONN-LIB-接插件库"><a href="#1-4-CONN-LIB-接插件库" class="headerlink" title="1.4 CONN.LIB(接插件库)"></a>1.4 CONN.LIB(接插件库)</h4><table><thead><tr><th>元件种类</th><th>简称</th><th>命名</th></tr></thead><tbody><tr><td>端子排座:包括导电插片、四脚端子等</td><td>CON</td><td>简称+PIN 数</td></tr><tr><td>排线</td><td>CN</td><td>简称+PIN 数</td></tr><tr><td>其他连接器</td><td>CON</td><td>简称-型号</td></tr></tbody></table><h4 id="1-5-DISPLAY-LIB-光电器件库"><a href="#1-5-DISPLAY-LIB-光电器件库" class="headerlink" title="1.5 DISPLAY.LIB(光电器件库)"></a>1.5 DISPLAY.LIB(光电器件库)</h4><table><thead><tr><th>元件种类</th><th>简称</th><th>命名</th></tr></thead><tbody><tr><td>发光二极管</td><td>LED</td><td>LED</td></tr><tr><td>双发光二极管</td><td>LED</td><td>LED2</td></tr><tr><td>数码管</td><td>LED</td><td>简称+位数-型号</td></tr><tr><td>数码屏</td><td>LED</td><td>简称-型号</td></tr><tr><td>背光板</td><td>BL</td><td>简称-型号</td></tr><tr><td>LCD</td><td>LCD</td><td>简称-型号</td></tr></tbody></table><h4 id="1-6-MARK-LIB-标示库"><a href="#1-6-MARK-LIB-标示库" class="headerlink" title="1.6 MARK.LIB(标示库)"></a>1.6 MARK.LIB(标示库)</h4><table><thead><tr><th>元件种类</th><th>简称</th><th>命名</th></tr></thead><tbody><tr><td>-5VDC电源</td><td>-5V</td><td>-5V</td></tr><tr><td>-18VDC电源</td><td>-18V</td><td>-18V</td></tr><tr><td>220VAC电源</td><td>AC</td><td>220VAC</td></tr><tr><td>A点</td><td>A</td><td>A点</td></tr><tr><td>B点</td><td>B</td><td>B点</td></tr><tr><td>共地点</td><td></td><td></td></tr><tr><td>信号</td><td></td><td></td></tr></tbody></table><h4 id="1-7-OTHER-LIB-其他元器件库"><a href="#1-7-OTHER-LIB-其他元器件库" class="headerlink" title="1.7 OTHER.LIB(其他元器件库)"></a>1.7 OTHER.LIB(其他元器件库)</h4><table><thead><tr><th>元件种类</th><th>简称</th><th>命名</th></tr></thead><tbody><tr><td>按键开关</td><td>SW</td><td>简称-型号</td></tr><tr><td>触摸按键</td><td>MO</td><td>MO</td></tr><tr><td>晶振</td><td>Y</td><td>简称-型号</td></tr><tr><td>保险管</td><td>F</td><td>FUSE</td></tr><tr><td>蜂鸣器</td><td>BZ</td><td>BUZ</td></tr><tr><td>继电器</td><td>K</td><td>K</td></tr><tr><td>电池</td><td>BAT</td><td>BAT</td></tr><tr><td>模块</td><td></td><td>简称-型号</td></tr></tbody></table><h3 id="2-原理图图形要求"><a href="#2-原理图图形要求" class="headerlink" title="2. 原理图图形要求"></a>2. 原理图图形要求</h3><ol><li>只要元器件上有的管脚，图形库都应体现出来，不允许使用隐含管脚的方式(包括未使用的管脚)。</li><li>电气管脚的长度为 5 的倍数。</li><li>管脚号命名和 PCB 封装上的<code>Designator</code>一致对应。</li><li>管脚名称<code>Name</code>缩写按规格书。</li><li>对连接器、插针等有2列的接插件，管脚号的命名顺序要求按照管脚顺序号进行排列。</li><li>对 IC 器件，做成矩形或方形。对于管脚的安排，可根据功能模块和管脚号的顺序综合考虑管脚的排列，原则输入放置在左边，输出放置在右边，电源放置在上边，地放置在下面。</li><li>对电阻、电容、电感、二极管、发光二极管、三极管、保险丝、开关、电池等分立器件及小封装器件，图形使用常见的简易图形表示。</li><li><code>Electrical Type</code>如果你不做仿真 无所谓类型是什么,一般不用改，默认即可。</li></ol><h3 id="3-原理图中元件值标注规则"><a href="#3-原理图中元件值标注规则" class="headerlink" title="3. 原理图中元件值标注规则"></a>3. 原理图中元件值标注规则</h3><p><strong>1.电阻：</strong></p><ul><li>电阻如只标数值，则代表其功率低于<code>1/4W</code>。如果其功率大于<code>1/4W</code>，则需要标明实际功率;</li><li>缺省定义为<code>“精度±5%”</code>;</li><li>为区别电阻种类可在其后标明: CF 碳膜、MF 金属膜、PF 氧化膜、FS 熔断、CE 瓷壳;</li></ul><table><thead><tr><th>阻值</th><th>规则</th></tr></thead><tbody><tr><td>≤1ohm</td><td>以小数表示，而不以毫欧表示 <code>0RXX</code>，例如 <code>0R47</code>、<code>0R033</code></td></tr><tr><td>≤999ohm</td><td>整数表示为 <code>XXR</code>，例如<code>100R</code>、<code>470R</code></td></tr><tr><td>≤999K</td><td>整数表示为 <code>XXK</code>，例如<code>100K</code>、<code>470K</code></td></tr><tr><td>≤999K 包含小数</td><td>表示为<code>XKX</code>，例如<code>4K7</code>、<code>4K99</code>、<code>49K9</code></td></tr><tr><td>≥1M</td><td>整数表示为 <code>XXM</code>，例如<code>1M</code>、<code>10M</code></td></tr><tr><td>≥1M 包含小数</td><td>表示为<code>XMX</code>，例如<code>4M7</code>、<code>2M2</code></td></tr></tbody></table><p><strong>2.电容：</strong>容值后标明耐压，以<code>“/”</code>与容值隔开。电解电容必须标明耐压，其他介质电容，如不标明耐压，则缺省定义为<code>“耐压50V”</code>。</p><table><thead><tr><th>容值</th><th>规则</th></tr></thead><tbody><tr><td>≤1pF</td><td>以小数加 p 表示，例如<code>0p47</code></td></tr><tr><td>≤100pF</td><td>整数表示为 <code>XXp</code>，例如<code>100p</code>、<code>470p</code></td></tr><tr><td>≥100pf</td><td>采用指数标示，如: 1000PF 为<code>102</code></td></tr><tr><td>≤999pF 包含小数</td><td>表示为<code>XpX</code>，例如<code>4p7</code>、<code>6p8</code>；接近 1uF 的电容，可以以<code>0.XXu</code>表示，例如<code>0.1u</code>、<code>0.22u</code></td></tr><tr><td>≥1uF</td><td>整数表示为 <code>XXu F+“耐压”</code>，例如 <code>100uF/25V</code>、<code>470uF/16V</code></td></tr><tr><td>≥1uF 包含小数</td><td>表示为<code>X.X+“耐压</code>”，例如<code>2.2uF/400V</code></td></tr></tbody></table><p><strong>3.电感：</strong>电感的电感量标法同电容容量标法。<br><strong>4.变压器：</strong>按实际型号<br><strong>5.二极管：</strong>按实际型号<br><strong>6.三极管：</strong>按实际型号<br><strong>7.集成电路：</strong>按实际型号<br><strong>8.接插件：</strong>标明脚数<br><strong>9.光电器件：</strong>按实际型号<br><strong>10.其他元件：</strong>按实际型号</p><h2 id="三、PCB封装建库规范"><a href="#三、PCB封装建库规范" class="headerlink" title="三、PCB封装建库规范"></a>三、PCB封装建库规范</h2><h3 id="1-PCB封装库分类及命名"><a href="#1-PCB封装库分类及命名" class="headerlink" title="1. PCB封装库分类及命名"></a>1. PCB封装库分类及命名</h3><p>依据元器件工艺类(一律采用大写字母)：</p><h4 id="1-1-SMD-LIB-贴片封装库"><a href="#1-1-SMD-LIB-贴片封装库" class="headerlink" title="1.1 SMD.LIB(贴片封装库)"></a>1.1 SMD.LIB(贴片封装库)</h4><table><thead><tr><th>元件种类</th><th>简称</th><th>封装名</th></tr></thead><tbody><tr><td>SMD 电阻</td><td>R</td><td>简称+元件英制代号</td></tr><tr><td>SMD 排阻</td><td>RA</td><td>简称+电阻数-PIN距</td></tr><tr><td>SMD 电容</td><td>C</td><td>简称+元件英制代号</td></tr><tr><td>SMD 电解电容</td><td>C</td><td>简称+元件直径</td></tr><tr><td>SMD 电感</td><td>L</td><td>简称+元件英制代号</td></tr><tr><td>SMD 钽电容</td><td>CT</td><td>简称+元件英制代号</td></tr><tr><td>柱状贴片</td><td>M</td><td>简称+元件英制代号</td></tr><tr><td>SMD 二极管</td><td>D</td><td>简称+元件英制代号</td></tr><tr><td>SMD 三极管</td><td>Q</td><td>常规为 SOT23 ;其他为<code>简称-型号</code></td></tr><tr><td>SMD IC</td><td>U</td><td>1．封装+PIN数,如: <code>PLCC6</code>、<code>QFP8</code>、<code>SOP8</code>、<code>SSOP8</code>、<code>TSOP8</code>; 2．IC型号+封装+PIN数</td></tr><tr><td>接插件</td><td>CON</td><td>简称+PIN数-PIN距</td></tr></tbody></table><h4 id="1-2-AI-LIB-机插封装库"><a href="#1-2-AI-LIB-机插封装库" class="headerlink" title="1.2 AI.LIB(机插封装库)"></a>1.2 AI.LIB(机插封装库)</h4><table><thead><tr><th>元件种类</th><th>简称</th><th>封装名</th></tr></thead><tbody><tr><td>电阻</td><td>R</td><td>简称+跨距(mm)</td></tr><tr><td>瓷片电容</td><td>C</td><td>CAP+跨距(mm)-直径</td></tr><tr><td>聚丙烯电容</td><td>C</td><td>简称+跨距(mm)-长X宽</td></tr><tr><td>涤纶电容</td><td>C</td><td>简称+跨距(mm)-长X宽</td></tr><tr><td>电解电容</td><td>C</td><td>简称+直径-跨距(mm);立式电容：简称+直径*高度-跨距(mm)+L</td></tr><tr><td>二极管</td><td>D</td><td>简称+直径-跨距(mm)</td></tr><tr><td>三极管类</td><td>Q</td><td>简称-型号</td></tr><tr><td>MOS管类</td><td>Q</td><td>简称-型号</td></tr><tr><td>三端稳压IC</td><td>U</td><td>简称-型号</td></tr><tr><td>LED</td><td>LED</td><td>简称-直径+跨距(mm)</td></tr></tbody></table><h4 id="1-2-DIP-LIB-手插封装库"><a href="#1-2-DIP-LIB-手插封装库" class="headerlink" title="1.2 DIP.LIB(手插封装库)"></a>1.2 DIP.LIB(手插封装库)</h4><table><thead><tr><th>元件种类</th><th>简称</th><th>封装名</th></tr></thead><tbody><tr><td>立插电阻</td><td>R</td><td>RV+跨距(mm)-直径</td></tr><tr><td>水泥电阻</td><td>R</td><td>RV+跨距(mm)-长X宽</td></tr><tr><td>压敏压阻</td><td>RZ</td><td>简称-型号</td></tr><tr><td>热敏电阻</td><td>RT</td><td>简称+跨距(mm)</td></tr><tr><td>光敏电阻</td><td>RL</td><td>简称-型号</td></tr><tr><td>可调电阻</td><td>VR</td><td>简称-型号</td></tr><tr><td>排阻</td><td>RA</td><td>简称+电阻数-PIN距</td></tr><tr><td>卧插电容</td><td>C</td><td>CW+跨距(mm)-直径X高</td></tr><tr><td>盒状电容</td><td>C</td><td>简称+跨距(mm)-长X宽</td></tr><tr><td>立式电解电容</td><td>C</td><td>简称+跨距(mm)-直径</td></tr><tr><td>电感</td><td>L</td><td>简称+电感数-型号</td></tr><tr><td>变压器</td><td>T</td><td>简称-型号</td></tr><tr><td>桥式整流器</td><td>BG</td><td>简称-型号</td></tr><tr><td>三极管</td><td>Q</td><td>简称-型号</td></tr><tr><td>IGBT</td><td>Q</td><td>IGBT-序号</td></tr><tr><td>MOS管</td><td>Q</td><td>简称-型号</td></tr><tr><td>单向可控硅</td><td>SCR</td><td>简称-型号</td></tr><tr><td>双向可控硅</td><td>BCR</td><td>简称-型号</td></tr><tr><td>三端稳压IC</td><td>U</td><td>简称-型号</td></tr><tr><td>光电耦合器类</td><td>U</td><td>简称+PIN数，如: PLCC6、QFP8、SOP8、SSOP8、TSOP8</td></tr><tr><td>IC</td><td>U</td><td>如上</td></tr><tr><td>排座</td><td>CON</td><td>1.PIN距为2.54mm:简称+PIN数; 2.PIN非为2.54mm:简称+PIN数-PIN距; 3.弯角-W、普通-L</td></tr><tr><td>排线</td><td>CN</td><td>如上</td></tr><tr><td>排针</td><td>SIP</td><td>如上</td></tr><tr><td>其他连接器</td><td>CON</td><td>如上</td></tr><tr><td>发光二极管</td><td>LED</td><td>简称+跨距(mm)-直径</td></tr><tr><td>双发光二极管</td><td>LED</td><td>LED2+跨距(mm)-直径</td></tr><tr><td>数码管</td><td>LED</td><td>LED+位数-尺寸</td></tr><tr><td>数码屏</td><td>LED</td><td>简称-型号</td></tr><tr><td>背光板</td><td>BL</td><td>简称-型号</td></tr><tr><td>LCD</td><td>LCD</td><td>简称-型号</td></tr><tr><td>按键开关</td><td>SW</td><td>简称-型号</td></tr><tr><td>触摸按键</td><td>MO</td><td>简称-型号</td></tr><tr><td>晶振</td><td>Y</td><td>简称-型号</td></tr><tr><td>保险管</td><td>F</td><td>简称+跨距(mm)-长X直径</td></tr><tr><td>蜂鸣器</td><td>BUZ</td><td>简称+跨距(mm)-直径</td></tr><tr><td>继电器</td><td>K</td><td>简称-型号</td></tr><tr><td>电池</td><td>BAT</td><td>简称-直径</td></tr><tr><td>电池片</td><td></td><td>型号</td></tr><tr><td>模块</td><td>MK</td><td>简称-型号</td></tr></tbody></table><h4 id="1-3-MARK-LIB-标示库"><a href="#1-3-MARK-LIB-标示库" class="headerlink" title="1.3 MARK.LIB(标示库)"></a>1.3 MARK.LIB(标示库)</h4><table><thead><tr><th>元件种类</th><th>简称</th><th>封装名</th></tr></thead><tbody><tr><td>MARK点</td><td>MARK</td><td></td></tr><tr><td>AI孔</td><td>AI</td><td></td></tr><tr><td>螺丝孔</td><td>M</td><td></td></tr><tr><td>测试点</td><td>TP</td><td></td></tr><tr><td>过炉方向</td><td>SOL</td><td></td></tr></tbody></table><h3 id="2-PCB封装图形要求"><a href="#2-PCB封装图形要求" class="headerlink" title="2. PCB封装图形要求"></a>2. PCB封装图形要求</h3><ol><li>外形尺寸：指元件的最大外型尺寸。封装库的外形(尺寸和形状)必须和实际元件的封装外形一致。</li><li>主体尺寸：指元件的塑封体的尺寸=宽度X长度。</li><li>尺寸单位：英制单位为mil，公制单位为mm。</li><li>封装的焊盘必须定义编号，一般使用数字来编号，和原理图对应。</li><li>贴片元件的原点一般设定在元件图形的中心。</li><li>插装元件原点一般设定在第一个焊盘中心。</li><li>表面贴装元件的封装必须在元件面建立，不允许在焊接面建立镜像的封装。</li><li>封装的外形建立在丝印层上。</li></ol><h2 id="四、PCB封装焊盘设计规范"><a href="#四、PCB封装焊盘设计规范" class="headerlink" title="四、PCB封装焊盘设计规范"></a>四、PCB封装焊盘设计规范</h2><h3 id="1-通用要求"><a href="#1-通用要求" class="headerlink" title="1. 通用要求"></a>1. 通用要求</h3><ol><li>所有焊盘单边最小不小于0.25mm，整个焊盘直径最大不大于元件孔径的3倍。</li><li>孔径超过1.2mm或焊盘直径超过3.0mm的焊盘应设计为星形或梅花焊盘。</li><li>PCB 上尚无件封装库的器件，应根据器件资料建立新的元件封装库，并保证丝印库存与实物相符合，特别是新建立的电磁元件、自制结构件等的元件库是否与元件的资料(承认书、规格书、图纸)相符合。新器件应建立能够满足不同工艺(回流焊、波峰焊、通孔回流焊)要求的元件库。</li></ol><h3 id="2-AI元件的封装设计"><a href="#2-AI元件的封装设计" class="headerlink" title="2. AI元件的封装设计"></a>2. AI元件的封装设计</h3><ol><li>单面AI板元件孔径=元件脚径+0.4mm。焊盘直径=2×孔径，焊盘间距不足0.7mm采用椭圆设计。</li><li>卧插元件(包括跳线)插孔的中心距：跨距要求为6-18mm。</li><li>卧插元件形体的限制：1W及以上电阻不进行AI。引线直径 ≥ 0.8mm不进行AI。</li><li>立插元件插孔的中心距：跨距要求为2.5mm、5.0mm两种规格。</li><li>立插元件形体的限制：最大高度可为16mm，最大直径为10mm。</li><li>立式平贴PCB元件在本体下增加0.8mm透气孔。</li><li>AI弯脚方向要有做丝印。</li><li>常用AI元件的PCB封装数据。</li></ol><table><thead><tr><th>元件名称</th><th>规格</th><th>孔径(mm)</th><th>焊盘(mm)</th><th>跨距(mm)</th><th>其他要求</th></tr></thead><tbody><tr><td>跳线Φ</td><td>0.6</td><td>1.00</td><td>2.0*2.0</td><td>10.00</td><td></td></tr><tr><td>电阻</td><td>1/4W及以下</td><td>1.00</td><td>2.0*2.0</td><td>10.00</td><td></td></tr><tr><td>电阻</td><td>1/2W</td><td>1.00</td><td>2.2*2.2</td><td>15.00</td><td></td></tr><tr><td>电解电容</td><td>脚距2.54mm</td><td>1.00</td><td>1.7*2.2</td><td>2.54</td><td>加0.8走气孔</td></tr><tr><td>电解电容</td><td>脚距5.0mm</td><td>1.00</td><td>2.0*2.0</td><td>5.00</td><td>加0.8走气孔</td></tr><tr><td>瓷片电容</td><td>脚距5.0mm</td><td>1.00</td><td>2.0*2.0</td><td>5.00</td><td></td></tr><tr><td>涤纶电容</td><td>脚距5.0mm</td><td>1.00</td><td>2.0*2.0</td><td>5.00</td><td></td></tr><tr><td>二极管</td><td>4148</td><td>1.00</td><td>2.0*2.0</td><td>10.00</td><td></td></tr><tr><td>二极管</td><td>4007</td><td>1.20</td><td>2.4*2.4</td><td>10.00</td><td></td></tr><tr><td>三极管</td><td>脚距2.54mm</td><td>1.00</td><td>1.7*2.2</td><td>2.54</td><td></td></tr><tr><td>LED</td><td>脚距2.28mm</td><td>1.00</td><td>1.6*2.2</td><td>2.28</td><td>加0.8走气孔</td></tr></tbody></table><h3 id="3-DIP元件的封装设计"><a href="#3-DIP元件的封装设计" class="headerlink" title="3. DIP元件的封装设计"></a>3. DIP元件的封装设计</h3><ol><li>元件孔径=元件脚径+0.2mm。焊盘直径=2×孔径+0.2mm，焊盘间距不足0.7mm采用椭圆设计。</li><li>焊盘≥3 *3mm要求做成梅花焊盘。梅花焊盘的要求：线宽0.7mm，露出焊盘0.5mm，角度30度，12条，外加线宽1.2mm阻焊。</li><li>排插脚间距≤2.54mm的要求在元件脚间加阻焊和偷锡焊盘。</li><li>所有接插件等受力器件或重量大的器件的焊盘引线2mm以内其包覆铜膜宽度要求尽可能增大并且不能有空焊盘设计，保证焊盘足够吃锡，插座受外力时不会轻易起铜皮。</li><li>常用DIP元件的PCB封装数据。</li></ol><table><thead><tr><th>元件名称</th><th>规格</th><th>孔径(mm)</th><th>焊盘(mm)</th><th>跨距(mm)</th><th>其他要求</th></tr></thead><tbody><tr><td>1W电阻</td><td></td><td>1.00</td><td>2.2*2.2</td><td>15.00</td><td></td></tr><tr><td>Φ1.5康铜丝</td><td></td><td>1.80</td><td>5.0*5.0</td><td>25.00</td><td>梅花焊盘</td></tr><tr><td>压敏电阻</td><td></td><td>1.20</td><td>2.4*2.4</td><td>7.50</td><td></td></tr><tr><td>可调电位器</td><td></td><td>1.00</td><td>2.0*2.5</td><td></td><td></td></tr><tr><td>2uF聚丙烯电容中型5uF和0.3uF</td><td></td><td>1.10</td><td>4*4</td><td>26.50</td><td></td></tr><tr><td>聚丙烯电容小型5uF和0.3uF</td><td></td><td>1.30</td><td>4*4</td><td>30.50</td><td></td></tr><tr><td>聚丙烯电容</td><td></td><td>1.30</td><td>4*4</td><td>26.50</td><td></td></tr><tr><td>Φ1.2mm扼流圈</td><td></td><td>1.50</td><td>4*10</td><td></td><td>梅花焊盘加弯脚</td></tr><tr><td>变压器EE10</td><td></td><td>1.00</td><td>2.2*2.2</td><td></td><td></td></tr><tr><td>整流桥堆</td><td></td><td>1.50</td><td>3.5*4.5</td><td></td><td>梅花焊盘</td></tr><tr><td>IGBT</td><td></td><td>1.50</td><td>3.5*4.5</td><td></td><td>梅花焊盘</td></tr><tr><td>IC(DIP8)</td><td>脚距2.54</td><td>1.00</td><td>1.7*2.2</td><td>2.54</td><td>加拖锡焊盘、阻焊</td></tr><tr><td>排线</td><td>脚距2.54</td><td>1.00</td><td>1.7*2.2</td><td>2.54</td><td>加拖锡焊盘、阻焊</td></tr><tr><td>2.54mm连接器</td><td>脚距2.54</td><td>1.00</td><td>1.7*2.2</td><td>2.54</td><td>加拖锡焊盘、阻焊</td></tr><tr><td>防倒导电插片</td><td></td><td>1.1*1.7方孔</td><td>3.5*4.5</td><td>5.00</td><td>梅花焊盘</td></tr><tr><td>四脚端子</td><td></td><td>1.2*1.7方孔</td><td>3.5*4.5</td><td></td><td>梅花焊盘</td></tr><tr><td>轻触开关    四脚</td><td></td><td>1.15</td><td>2.0*2.5</td><td></td><td></td></tr><tr><td>轻触开关    二脚</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>数码管</td><td>脚距2.54</td><td>0.80</td><td>1.6*2.5</td><td>2.54</td><td>加拖锡焊盘、阻焊</td></tr><tr><td>12.5A保险管</td><td></td><td>1.20</td><td>3.5*3.5</td><td>21.00</td><td>梅花焊盘</td></tr><tr><td>电磁式蜂鸣器</td><td></td><td>1.00</td><td>2.0*2.0</td><td>6.60</td><td></td></tr><tr><td>压电式蜂鸣器</td><td></td><td>1.00</td><td>2.0*2.0</td><td>7.50</td><td></td></tr></tbody></table><h3 id="4-SMT元件的封装设计"><a href="#4-SMT元件的封装设计" class="headerlink" title="4. SMT元件的封装设计"></a>4. SMT元件的封装设计</h3><ol><li>为了统一SMT生产贴片时的元件贴装角度，保证各元件角度的一次正确性，在建立标准元件封装库时，其封装库的初始角度必须统一标准化。标准元件封装库的元件角度设计要求：</li></ol><p><img src="https://chafanzhai-com.oss-cn-shanghai.aliyuncs.com/img/1562066657.png" alt="角度.png"></p><ol start="2"><li>常用阻容贴片的焊盘设计</li></ol><p><img src="https://chafanzhai-com.oss-cn-shanghai.aliyuncs.com/img/3009260744.png" alt="阻容贴片.png"></p><p>常用阻容贴片的红胶工艺焊盘设计:</p><table><thead><tr><th>外形代号(in)</th><th>0402</th><th>0603</th><th>0805</th><th>1206</th></tr></thead><tbody><tr><td>W：宽mm[mil]</td><td>0.56[22]</td><td>0.79[31]</td><td>1.27[50]</td><td>1.60[63]</td></tr><tr><td>L：长mm[mil]</td><td>0.89[35]</td><td>1.25[50]</td><td>1.70[67]</td><td>1.32[52]</td></tr><tr><td>T：距 mm[mil]</td><td>0.40[16]</td><td>0.60[24]</td><td>0.86[32]</td><td>1.80[72]</td></tr></tbody></table><ol><li>常用SOT23封装三极管的焊盘设计</li></ol><p><img src="https://chafanzhai-com.oss-cn-shanghai.aliyuncs.com/img/20186873.png" alt="三极管.png"></p><ol><li><p>圆柱状类(如二极管)的焊盘设计应尊循两端焊盘的中心距为元件的长度这一原则，焊盘的宽度和长度一般以同类型封装的片式阻容一致。</p></li><li><p>IC表面焊盘图形设计的一般原则 </p><ul><li>对SOP、QFP、PLCC、BGA存在着英制和公制两种规格，而且除了 PLCC 外，其他封装形式很不标准，各个厂家的封装尺寸不完全一致。设计时，应以供应商提供的封装结构尺寸来进行设计； </li><li>焊盘中心等于引线中心距；</li><li>焊盘宽度一般取引脚中心距的一半；</li><li>焊盘与相邻印制线间隔不应小于 0.3mm。 </li></ul></li></ol><p><strong>SOT设计的一般原则</strong></p><ul><li>焊盘的中心距与引线的中心距相等；</li><li>焊盘的图形与引线的焊接面相似，尺寸上一般是在长度方向上加长 1mm，在宽度方向上加宽0.4mm。</li><li>用SOP封装IC的焊盘设计如果是红胶工艺必须加拖锡焊盘。</li></ul><p><img src="https://chafanzhai-com.oss-cn-shanghai.aliyuncs.com/img/20191019192907-2019-10-19-19-29-7.png" alt="sop.jpg"></p><p><strong>PLCC设计的一般原则</strong></p><p>元件与焊盘的形状以及式中字母的意义，如图所示</p><ul><li>焊盘中心距等于引线中心距；</li><li>焊盘宽度等于引线中心距一半；</li><li>A或B=Cmax+0.8mm；</li><li>L=2.0mm～2.15mm。</li></ul><p><img src="https://chafanzhai-com.oss-cn-shanghai.aliyuncs.com/img/20191019193011-2019-10-19-19-30-11.png" alt="plcc.png"></p><p><strong>QFP设计的一般原则</strong><br>元件与焊盘的形状以及式中字母的意义，如图所示</p><ul><li>焊盘中心距等于引线中心距；</li><li>焊盘宽度等于引线中心距之半加0.05mm； </li><li>A’(或B’)=A(或B)+1mm；</li><li>L=1.5mm～1.6mm(适合于引线中心距为 0.5mm及其以下尺寸的 QFP)；</li><li>L=1.8mm～2.0mm(适合于引线中心距为 0.8mm、0.65mm 尺寸的QFP)。</li><li>用QFT封装IC的焊盘设计如果是红胶工艺必须加拖锡焊盘。</li></ul><p><img src="https://chafanzhai-com.oss-cn-shanghai.aliyuncs.com/img/20191019193054-2019-10-19-19-30-54.png" alt="qfp.png"></p><h3 id="5-特殊元件的封装设计"><a href="#5-特殊元件的封装设计" class="headerlink" title="5. 特殊元件的封装设计"></a>5. 特殊元件的封装设计</h3><p>12.5A铜箔保险丝：<br><img src="https://chafanzhai-com.oss-cn-shanghai.aliyuncs.com/img/20191019193128-2019-10-19-19-31-28.png" alt="12.5cu.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 手段方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Altium Designer </tag>
            
            <tag> 设计规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Altium Designer 在绘制 PCBLayout 时各层的用途</title>
      <link href="2019/10/16/altium-designer-zai-hui-zhi-pcblayout-shi-ge-ceng-de-yong-tu/"/>
      <url>2019/10/16/altium-designer-zai-hui-zhi-pcblayout-shi-ge-ceng-de-yong-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-各层的作用涵义"><a href="#1-各层的作用涵义" class="headerlink" title="1.各层的作用涵义"></a>1.各层的作用涵义</h2><p><code>信号层(Signal Layers)</code>: 信号层包括 Top Layer、Bottom Layer、Mid Layer(1-30)。这些层都是具有电气连接的层，也就是实际的铜层。中间层是指用于布线的中间板层，该层中布的是导线。<br><code>内层(Internal Plane)</code>: Internal Plane(1-16)，这些层一般连接到地和电源上，成为电源层和地层，也具有电气连接作用，也是实际的铜层，但该层一般情况下不布线，是由整片铜膜构成。<br><code>丝印层(Silkscreen Overlay)</code>: 包括顶层丝印层(Top overlay)和底层丝印层(Bottom overlay)。定义顶层和底层的丝印字符，就是一般在阻焊层之上印的一些文字符号，比如元件名称、元件符号、元件管脚和版权等，方便以后的电路焊接和查错等。<br><code>锡膏层(Paste Mask)</code>: 包括顶层锡膏层(Top paste)和底层锡膏层(Bottom paste)，指我们可以看到的露在外面的表面贴装焊盘，也就是在焊接前需要涂焊膏的部分。所以，这一层在焊盘进行热风整平和制作焊接钢网时也有用。<br><code>阻焊层(Solder Mask)</code>: 包括顶层阻焊层(Top solder)和底层阻焊层(Bottom solder)，其作用与锡膏层相反，指的是要盖绿油的层。该层不粘焊锡，防止在焊接时相邻焊接点的多余焊锡短路。阻焊层将铜膜导线覆盖住，防铜膜过快在空气中氧化，但是在焊点处留出位置，并不覆盖焊点。<br><code>机械层(Mechanical Layers)</code>: 最多可选择 16 层机械加工层。设计双面板只需要使用默认选项 Mechanical Layer 1。<br><code>禁布层(Keep Out Layer)</code>: 定义布线层的边界。定义了禁止布线层后，在以后的布线过程中，具有电气特性的布线不可以超出禁止布线层的边界。<br><code>钻孔层(Drill Layer)</code>: 包括钻孔引导层(Drill guide)和钻孔数据层(Drill drawing),是钻孔的数据。<br><code>多层(Multi-layer)</code>:指PCB板的所有层。（添加：有些说法叫层间走线，就是过孔和焊盘等，但是板的挖空多边形也会显示）</p><h2 id="2-机械层的一些比较通用的约定"><a href="#2-机械层的一些比较通用的约定" class="headerlink" title="2.机械层的一些比较通用的约定"></a>2.机械层的一些比较通用的约定</h2><p><code>Mechanical Layer</code> 顾名思义就是机械层，之所以强调“机械”就是说它不带有电气属性，因此可以放心地用于勾画外形、勾画机械尺寸、放置文本等等工作，而不必担心对板子的电气特性造成任何改变。<br>机械层的功能是可以根据自己的需求来定义的，以下是个人较习惯用的机械层定义：<br><code>Mech1</code>：机械一层多用来勾画线路板的边框，以及内部较大的镂空或者异型镗孔。<br><code>Mech2</code>：机械二层多用来绘制V型槽。<br><code>Mech3-4</code>：机械三、四层多用来放置辅助定义边界，以及特殊的分隔线。<br><code>Mech5-6</code>：机械五、六层多用来放置线路板的尺寸标注。<br><code>Mech7-8</code>：机械七、八层多用来放置各种描述文本，如板号名称、版本号、加工说明、设计者、设计日期等等。<br><code>Mech13</code>：AD默认用于描述器件的物理外形，也用于绘制三维实体。<br><code>Mech14</code>：同上。<br><code>Mech15</code>：AD默认用于勾绘器件的占位尺寸。<br><code>Mech16</code>：同上。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCB </tag>
            
            <tag> Altium Designer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令及操作笔记</title>
      <link href="2019/10/01/git-chang-yong-ming-ling-ji-cao-zuo-bi-ji/"/>
      <url>2019/10/01/git-chang-yong-ming-ling-ji-cao-zuo-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="场景操作指北"><a href="#场景操作指北" class="headerlink" title="场景操作指北"></a>场景操作指北</h2><h3 id="删除commit历史记录"><a href="#删除commit历史记录" class="headerlink" title="删除commit历史记录"></a>删除commit历史记录</h3><ol><li>新建无<code>commit</code>历史的分支<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> checkout --orphan latest_branch</code></pre></li><li>添加所有文件<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> add -A</code></pre></li><li>提交变更<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> commit -am <span class="token string">"commit message"</span></code></pre></li><li>删除<code>master</code>分支<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> branch -D master</code></pre></li><li>讲当前分支重命名为<code>master</code>分支<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> branch -m master</code></pre></li><li>最后推送到远程仓库<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> push -f origin master</code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
